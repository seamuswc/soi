{"version":3,"sources":["../../src/core/crypto/secp256r1.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { p256 } from \"@noble/curves/nist.js\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport {\n  HexInput,\n  PrivateKeyVariants,\n  SigningScheme as AuthenticationKeyScheme,\n  AnyPublicKeyVariant,\n} from \"../../types\";\nimport { PublicKey, VerifySignatureAsyncArgs } from \"./publicKey\";\nimport { PrivateKey } from \"./privateKey\";\nimport { Signature } from \"./signature\";\nimport { AuthenticationKey } from \"../authenticationKey\";\n\n/**\n * Represents a Secp256r1 ECDSA public key.\n *\n * @extends PublicKey\n * @property LENGTH - The length of the Secp256r1 public key in bytes.\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256r1PublicKey extends PublicKey {\n  // Secp256r1 ecdsa public keys contain a prefix indicating compression and two 32-byte coordinates.\n  static readonly LENGTH: number = 65;\n\n  // If it's compressed, it is only 33 bytes\n  static readonly COMPRESSED_LENGTH: number = 33;\n\n  // Hex value of the public key\n  private readonly key: Hex;\n\n  // Identifier to distinguish from Secp256k1PublicKey\n  public readonly keyType: string = \"secp256r1\";\n\n  /**\n   * Create a new PublicKey instance from a HexInput, which can be a string or Uint8Array.\n   * This constructor validates the length of the provided public key data.\n   *\n   * @param hexInput - A HexInput (string or Uint8Array) representing the public key data.\n   * @throws Error if the length of the public key data is not equal to Secp256r1PublicKey.LENGTH or COMPRESSED_LENGTH.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    const keyLength = hex.toUint8Array().length;\n    if (keyLength !== Secp256r1PublicKey.LENGTH && keyLength !== Secp256r1PublicKey.COMPRESSED_LENGTH) {\n      throw new Error(\n        `PublicKey length should be ${Secp256r1PublicKey.LENGTH} or ${Secp256r1PublicKey.COMPRESSED_LENGTH}, received ${keyLength}`,\n      );\n    }\n\n    if (keyLength === Secp256r1PublicKey.COMPRESSED_LENGTH) {\n      const point = p256.ProjectivePoint.fromHex(hex.toUint8Array());\n      this.key = Hex.fromHexInput(point.toRawBytes(false));\n    } else {\n      this.key = hex;\n    }\n  }\n\n  /**\n   * Get the data as a Uint8Array representation.\n   *\n   * @returns Uint8Array representation of the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Converts the public key to BCS (Binary Canonical Serialization) bytes.\n   * This function serializes the public key data into a byte array format suitable for transmission or storage.\n   *\n   * @returns Uint8Array representation of the serialized public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  bcsToBytes() {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n\n  /**\n   * Verifies a Secp256r1 signature against the public key.\n   *\n   * This function checks the validity of a signature for a given message.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: Signature }): boolean {\n    const { message, signature } = args;\n\n    const msgHex = Hex.fromHexInput(message).toUint8Array();\n    const sha3Message = sha3_256(msgHex);\n    const rawSignature = signature.toUint8Array();\n\n    return p256.verify(rawSignature, sha3Message, this.toUint8Array());\n  }\n\n  /**\n   * Note: Secp256r1Signatures can be verified synchronously.\n   *\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of Secp256r1Signature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean> {\n    return this.verifySignature({ message: args.message, signature: args.signature });\n  }\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This function is essential for converting data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to convert the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  /**\n   * Deserializes a Secp256r1PublicKey from the provided deserializer.\n   * This function allows you to reconstruct a Secp256r1PublicKey object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): Secp256r1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1PublicKey(bytes);\n  }\n\n  /**\n   * Loads a Secp256r1PublicKey from the provided deserializer.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static load(deserializer: Deserializer): Secp256r1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1PublicKey(bytes);\n  }\n\n  /**\n   * Determines if the provided public key is a valid instance of a Secp256r1 public key.\n   * This function checks for the presence of a \"key\" property and validates the length of the key data.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid Secp256r1 public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is Secp256r1PublicKey {\n    return (\n      \"key\" in publicKey &&\n      (publicKey.key as any)?.data?.length === Secp256r1PublicKey.LENGTH &&\n      \"keyType\" in publicKey &&\n      (publicKey as any).keyType === \"secp256r1\"\n    );\n  }\n\n  /**\n   * Generates an authentication key from the public key using the Secp256r1 scheme.\n   * This function is essential for creating a secure authentication key that can be used for further cryptographic operations.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Secp256r1);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n}\n\n/**\n * Represents a Secp256r1 ECDSA private key, providing functionality to create, sign messages,\n * derive public keys, and serialize/deserialize the key.\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256r1PrivateKey extends PrivateKey {\n  /**\n   * Length of Secp256r1 ecdsa private key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The private key bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly key: Hex;\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   * @param strict If true, private key must AIP-80 compliant.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput, strict?: boolean) {\n    super();\n\n    const privateKeyHex = PrivateKey.parseHexInput(hexInput, PrivateKeyVariants.Secp256r1, strict);\n    const keyLength = privateKeyHex.toUint8Array().length;\n    if (keyLength !== Secp256r1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Secp256r1PrivateKey.LENGTH}, received ${keyLength}`);\n    }\n\n    this.key = privateKeyHex;\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a string representation.\n   *\n   * @returns string representation of the private key\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return PrivateKey.formatPrivateKey(this.key.toString(), PrivateKeyVariants.Secp256r1);\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   */\n  toHexString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Sign the given message with the private key.\n   * This function generates a cryptographic signature for the provided message.\n   *\n   * @param message - A message in HexInput format to be signed.\n   * @returns Signature - The generated signature for the provided message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Secp256r1Signature {\n    const msgHex = Hex.fromHexInput(message);\n    const sha3Message = sha3_256(msgHex.toUint8Array());\n    const signature = p256.sign(sha3Message, this.key.toUint8Array());\n    return new Secp256r1Signature(signature.toCompactRawBytes());\n  }\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This function is essential for converting data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to convert the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  /**\n   * Deserializes a Secp256r1PrivateKey from the provided deserializer.\n   * This function allows you to reconstruct a Secp256r1PrivateKey object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): Secp256r1PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1PrivateKey(bytes);\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Secp256r1PrivateKey - A newly generated Secp256r1 private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static generate(): Secp256r1PrivateKey {\n    const hexInput = p256.utils.randomPrivateKey();\n    return new Secp256r1PrivateKey(hexInput);\n  }\n\n  /**\n   * Derive the Secp256r1PublicKey from this private key.\n   *\n   * @returns Secp256r1PublicKey The derived public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): Secp256r1PublicKey {\n    const bytes = p256.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256r1PublicKey(bytes);\n  }\n}\n\nexport class WebAuthnSignature extends Signature {\n  signature: Hex;\n\n  authenticatorData: Hex;\n\n  clientDataJSON: Hex;\n\n  constructor(signature: HexInput, authenticatorData: HexInput, clientDataJSON: HexInput) {\n    super();\n    this.signature = Hex.fromHexInput(signature);\n    this.authenticatorData = Hex.fromHexInput(authenticatorData);\n    this.clientDataJSON = Hex.fromHexInput(clientDataJSON);\n  }\n\n  toUint8Array() {\n    return this.signature.toUint8Array();\n  }\n\n  serialize(serializer: Serializer) {\n    serializer.serializeU32AsUleb128(0);\n    serializer.serializeBytes(this.signature.toUint8Array());\n    serializer.serializeBytes(this.authenticatorData.toUint8Array());\n    serializer.serializeBytes(this.clientDataJSON.toUint8Array());\n  }\n\n  bcsToBytes() {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n\n  bcsToHex() {\n    return Hex.fromHexInput(this.bcsToBytes());\n  }\n\n  toStringWithoutPrefix() {\n    return Hex.fromHexInput(this.bcsToBytes()).toString();\n  }\n\n  static deserialize(deserializer: Deserializer) {\n    const id = deserializer.deserializeUleb128AsU32();\n    if (id !== 0) {\n      throw new Error(`Invalid id for WebAuthnSignature: ${id}`);\n    }\n    const signature = deserializer.deserializeBytes();\n    const authenticatorData = deserializer.deserializeBytes();\n    const clientDataJSON = deserializer.deserializeBytes();\n    return new WebAuthnSignature(signature, authenticatorData, clientDataJSON);\n  }\n}\n\n/**\n * Represents a signature of a message signed using a Secp256r1 ECDSA private key.\n *\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256r1Signature extends Signature {\n  /**\n   * Secp256r1 ecdsa signatures are 256-bit.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly data: Hex;\n\n  /**\n   * Create a new Signature instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    const signatureLength = hex.toUint8Array().length;\n    if (signatureLength !== Secp256r1Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Secp256r1Signature.LENGTH}, received ${signatureLength}`);\n    }\n    const signature = p256.Signature.fromCompact(hex.toUint8Array()).normalizeS().toCompactRawBytes();\n    this.data = Hex.fromHexInput(signature);\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return this.data.toString();\n  }\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This function is essential for converting data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to convert the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  /**\n   * Deserializes a Secp256r1Signature from the provided deserializer.\n   * This function allows you to reconstruct a Secp256r1Signature object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): Secp256r1Signature {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256r1Signature(hex);\n  }\n}\n"],"mappings":"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","names":["sha3_256","p256","_Secp256r1PublicKey","PublicKey","hexInput","hex","Hex","keyLength","point","p256","serializer","Serializer","args","message","signature","msgHex","sha3Message","sha3_256","rawSignature","deserializer","bytes","publicKey","AuthenticationKey","Secp256r1PublicKey","_Secp256r1PrivateKey","PrivateKey","strict","privateKeyHex","Secp256r1Signature","Secp256r1PrivateKey","WebAuthnSignature","_WebAuthnSignature","Signature","authenticatorData","clientDataJSON","id","_Secp256r1Signature","signatureLength"]}